# -*- coding: utf-8 -*-
"""Handwritten digit recognition NEW improve

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RZSA-vFoXgghoFZZZn-jGpAoR3XO65ki
"""

# STEP 1: Install libraries
!pip install -q tensorflow matplotlib pillow opencv-python-headless

# STEP 2: Imports
import numpy as np
import matplotlib.pyplot as plt
import cv2
from PIL import Image
from tensorflow.keras.datasets import mnist
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense
from tensorflow.keras.utils import to_categorical
from google.colab import files

# STEP 3: Load and preprocess MNIST dataset
(x_train, y_train), (x_test, y_test) = mnist.load_data()
x_train = x_train.reshape(-1, 28, 28, 1).astype('float32') / 255
x_test = x_test.reshape(-1, 28, 28, 1).astype('float32') / 255
y_train = to_categorical(y_train, 10)
y_test = to_categorical(y_test, 10)

# STEP 4: Build a better CNN model
model = Sequential([
    Conv2D(32, (3,3), activation='relu', input_shape=(28,28,1)),
    MaxPooling2D(2,2),
    Conv2D(64, (3,3), activation='relu'),
    MaxPooling2D(2,2),
    Flatten(),
    Dense(128, activation='relu'),
    Dense(10, activation='softmax')
])

# Compile
model.compile(optimizer='adam',
              loss='categorical_crossentropy',
              metrics=['accuracy'])

# STEP 5: Train the model longer (18 epochs)
model.fit(x_train, y_train, epochs=18, batch_size=64, validation_split=0.2)

# STEP 6: Accuracy check
loss, acc = model.evaluate(x_test, y_test)
print(f"‚úÖ Test Accuracy: {acc*100:.2f}%")

# STEP 7: Predict on uploaded images in a loop
while True:
    print("\nüîÅ Upload a digit image (or click stop)")
    uploaded = files.upload()

    if not uploaded:
        break

    for fn in uploaded.keys():
        print(f"\nüìÇ Processing: {fn}")

        # Load and preprocess image
        img = cv2.imread(fn, cv2.IMREAD_COLOR)
        img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        img_resized = cv2.resize(img_gray, (28, 28))
        img_blur = cv2.GaussianBlur(img_resized, (5,5), 0)

        # Threshold to isolate number
        img_thresh = cv2.adaptiveThreshold(img_blur, 255,
                                           cv2.ADAPTIVE_THRESH_GAUSSIAN_C,
                                           cv2.THRESH_BINARY_INV, 11, 2)

        # Normalize & reshape
        final_input = img_thresh / 255.0
        final_input = final_input.reshape(1, 28, 28, 1)

        # Predict
        prediction = model.predict(final_input)
        predicted_digit = np.argmax(prediction)

        # Display result
        plt.imshow(img_thresh, cmap='gray')
        plt.title(f"üß† Predicted: {predicted_digit}")
        plt.axis('off')
        plt.show()